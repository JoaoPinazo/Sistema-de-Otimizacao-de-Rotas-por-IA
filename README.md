Sabor Express - Sistema de OtimizaÃ§Ã£o de Rotas por IA (SORA)Este repositÃ³rio contÃ©m a soluÃ§Ã£o de InteligÃªncia Artificial desenvolvida para a empresa "Sabor Express", focada em otimizar seu processo de delivery de alimentos. O sistema utiliza algoritmos de clustering e busca em grafos para sugerir rotas eficientes, agrupar pedidos e reduzir custos operacionais.1. ğŸ¯ DescriÃ§Ã£o do Problema e ObjetivosO "Sabor Express" enfrenta desafios logÃ­sticos significativos durante os horÃ¡rios de pico (almoÃ§o e jantar). O gerenciamento manual das entregas resulta em:Rotas ineficientes e longos tempos de espera.Atrasos na entrega e insatisfaÃ§Ã£o dos clientes.Aumento no custo de combustÃ­vel e desgaste dos veÃ­culos.Baixa escalabilidade em perÃ­odos de alta demanda.Desafio Proposto:Desenvolver uma soluÃ§Ã£o inteligente (IA) que substitua o planejamento manual, capaz de processar mÃºltiplos pedidos simultÃ¢neos e gerar as rotas de entrega mais rÃ¡pidas e econÃ´micas.Objetivos do Projeto:Reduzir o tempo mÃ©dio de entrega atravÃ©s de roteirizaÃ§Ã£o otimizada.Aumentar a eficiÃªncia operacional, permitindo que cada entregador realize mais entregas por hora.Reduzir custos com combustÃ­vel.Melhorar a satisfaÃ§Ã£o do cliente com entregas mais rÃ¡pidas e previsÃ­veis.2. ğŸ’¡ Abordagem Adotada (A SoluÃ§Ã£o SORA)A soluÃ§Ã£o proposta Ã© um sistema de duas fases que lida com os dois principais gargalos da empresa: agrupamento e roteirizaÃ§Ã£o.Fase 1: Agrupamento de Pedidos (Clustering)Quando a demanda Ã© alta, Ã© ineficiente enviar um entregador para cada pedido. O sistema primeiro agrupa os pedidos pendentes com base em sua proximidade geogrÃ¡fica.Algoritmo: K-Means.Como funciona: O nÃºmero de "clusters" (K) Ã© definido com base no nÃºmero de entregadores disponÃ­veis no momento. O K-Means analisa as coordenadas (latitude/longitude) de todos os pedidos prontos e os agrupa em K "zonas" de entrega.Resultado: Cada entregador recebe um "lote" de pedidos geograficamente prÃ³ximos, evitando que diferentes entregadores cruzem a cidade para atender Ã¡reas vizinhas.Fase 2: OtimizaÃ§Ã£o da Rota (Pathfinding)ApÃ³s definir quais pedidos cada entregador levarÃ¡ (Fase 1), precisamos definir a ordem e o caminho mais eficientes para entregÃ¡-los.DefiniÃ§Ã£o da SequÃªncia (TSP): Para o lote de 3-5 pedidos de um entregador, o sistema resolve uma versÃ£o simplificada do Problema do Caixeiro Viajante (TSP). Ele calcula a sequÃªncia de visitaÃ§Ã£o (Restaurante -> P2 -> P4 -> P1 -> P3) que minimiza a distÃ¢ncia ou o tempo total da viagem.Encontrar o Caminho (A*): Com a sequÃªncia definida, o sistema usa o Algoritmo A* (A-Star) para encontrar o caminho exato nas ruas (o melhor trajeto) entre cada ponto da sequÃªncia (ex: do Restaurante ao P2, depois do P2 ao P4...).3. ğŸ¤– Algoritmos UtilizadosK-Means (Aprendizado NÃ£o Supervisionado)PropÃ³sito: Clustering (Agrupamento).Por quÃª? Ã‰ um algoritmo rÃ¡pido e eficiente para agrupar dados (pedidos) com base na sua localizaÃ§Ã£o no espaÃ§o (coordenadas geogrÃ¡ficas). Ele particiona os N pedidos nos K grupos (entregadores) mais compactos possÃ­veis.Grafo Ponderado (Estrutura de Dados)PropÃ³sito: RepresentaÃ§Ã£o do Mapa.Por quÃª? A cidade Ã© modelada como um grafo onde:NÃ³s (VÃ©rtices): Cruzamentos ou locais de entrega (incluindo o Sabor Express).Arestas (Edges): As ruas que conectam os nÃ³s.Pesos: O "custo" de percorrer a aresta. Nosso modelo usa tempo estimado ou distÃ¢ncia (neste projeto, usamos um CSV estÃ¡tico, mas a ideia Ã© que o peso seja dinÃ¢mico com base no trÃ¡fego).Algoritmo A* (A-Star) (Busca em Grafos)PropÃ³sito: Pathfinding (Encontrar o Menor Caminho).Por quÃª? O A* Ã© ideal para mapas. Diferente da Busca em Largura (BFS) ou Profundidade (DFS), que sÃ£o "cegas", o A* Ã© uma busca informada. Ele usa uma heurÃ­stica (a distÃ¢ncia em linha reta atÃ© o destino) para priorizar a exploraÃ§Ã£o de caminhos que "parecem" estar na direÃ§Ã£o certa, encontrando a rota Ã³tima de forma muito mais rÃ¡pida.FÃ³rmula: $f(n) = g(n) + h(n)$$g(n)$: Custo real do inÃ­cio atÃ© o nÃ³ $n$.$h(n)$: Custo heurÃ­stico (estimado) do nÃ³ $n$ atÃ© o destino.4. ğŸ—ºï¸ Diagrama do Grafo e Modelo da SoluÃ§Ã£oModelo Conceitual do GrafoO grafo abaixo representa uma versÃ£o simplificada da Ã¡rea central da cidade. Os nÃ³s A, B, C... sÃ£o pontos de entrega e cruzamentos. O "Sabor Express" Ã© o nÃ³ de origem. As arestas tÃªm pesos (ex: 5 minutos) que o A* usarÃ¡ para calcular a rota.``Fluxo da SoluÃ§Ã£o SORAEste diagrama ilustra o fluxo de dados desde o recebimento do pedido atÃ© a definiÃ§Ã£o da rota para o entregador.``5. ğŸ“‚ Estrutura do RepositÃ³rioO projeto estÃ¡ organizado da seguinte forma para facilitar a manutenÃ§Ã£o e execuÃ§Ã£o:sabor-express-ia/
â”œâ”€â”€ /data/
â”‚   â”œâ”€â”€ mapa_grafo.csv      # Arquivo com as arestas (ruas) e pesos (distÃ¢ncia/tempo)
â”‚   â””â”€â”€ pedidos_exemplo.csv # CSV com pedidos (ID, latitude, longitude)
â”œâ”€â”€ /src/
â”‚   â”œâ”€â”€ clustering.py       # MÃ³dulo com a implementaÃ§Ã£o do K-Means
â”‚   â”œâ”€â”€ pathfinding.py      # MÃ³dulo com a implementaÃ§Ã£o do A* e lÃ³gica do grafo
â”‚   â””â”€â”€ main.py             # Script principal que orquestra a soluÃ§Ã£o
â”œâ”€â”€ /outputs/
â”‚   â””â”€â”€ rota_otimizada.png  # Exemplo de output grÃ¡fico gerado
â”œâ”€â”€ .gitignore
â”œâ”€â”€ requirements.txt        # Lista de dependÃªncias Python
â””â”€â”€ README.md               # Esta documentaÃ§Ã£o
6. ğŸš€ InstruÃ§Ãµes para ExecuÃ§Ã£oPrÃ©-requisitosPython 3.8 ou superiorPip (Gerenciador de pacotes Python)Bibliotecas NecessÃ¡riasAs principais bibliotecas utilizadas neste projeto sÃ£o:Pandas: Para carregar e manipular os dados dos arquivos CSV.Scikit-learn: Para a implementaÃ§Ã£o do algoritmo K-Means.NetworkX: Para criar, manipular e analisar a estrutura de grafos.Matplotlib: Para visualizar os clusters e as rotas geradas.Passo a Passo para ExecuÃ§Ã£oClone o repositÃ³rio:Bashgit clone https://github.com/seu-usuario/sabor-express-ia.git
cd sabor-express-ia
Crie um ambiente virtual (Recomendado):Bashpython -m venv venv
source venv/bin/activate  # No Windows: venv\Scripts\activate
Instale as dependÃªncias:Bashpip install -r requirements.txt
Execute a simulaÃ§Ã£o:O script main.py carrega os dados de pedidos_exemplo.csv e o mapa_grafo.csv, executa o K-Means para agrupar (supondo K=3 entregadores) e, em seguida, calcula a rota A* para um dos clusters.Bashpython src/main.py
Outputs EsperadosA execuÃ§Ã£o do script main.py irÃ¡:Exibir no console os clusters de entrega definidos.Mostrar a sequÃªncia de rota otimizada (TSP) para o primeiro cluster.Imprimir o caminho detalhado (A*) entre os pontos.Gerar e salvar uma imagem em /outputs/rota_otimizada.png, mostrando um grÃ¡fico com os pontos de entrega, os clusters e as rotas calculadas.7. ğŸ“ˆ AnÃ¡lise de Resultados e LimitaÃ§ÃµesEficiÃªncia da SoluÃ§Ã£oK-Means: Ã‰ um algoritmo computacionalmente leve (complexidade prÃ³xima de $O(N)$ para $N$ pedidos), ideal para uma operaÃ§Ã£o em tempo real.A*: Muito mais eficiente que o BFS/DFS em mapas urbanos. Sua performance depende da qualidade da heurÃ­stica, mas Ã© comprovadamente Ã³timo e eficiente para este cenÃ¡rio.TSP: Ã‰ um problema $NP-hard$. No entanto, para o nÃºmero pequeno de paradas por cluster (ex: 3 a 7), podemos usar algoritmos de forÃ§a bruta ou aproximaÃ§Ãµes (como o "Vizinho Mais PrÃ³ximo") que rodam instantaneamente.LimitaÃ§Ãµes EncontradasGrafo EstÃ¡tico: A soluÃ§Ã£o atual usa um CSV com pesos fixos (distÃ¢ncia). Isso nÃ£o reflete condiÃ§Ãµes reais de trÃ¡fego, que mudam dinamicamente (ex: horÃ¡rio de pico vs. madrugada).Simplicidade do K-Means: O K-Means otimiza a distÃ¢ncia "em linha reta" (Euclidiana) para os clusters, nÃ£o o tempo de percurso nas ruas.RestriÃ§Ãµes Operacionais: O modelo nÃ£o considera o tempo de preparo do pedido, a capacidade da mochila do entregador (ex: mÃ¡ximo de 3 pedidos) ou janelas de horÃ¡rio de entrega.SugestÃµes de Melhoria (Trabalhos Futuros)Grafo DinÃ¢mico: Integrar a soluÃ§Ã£o com APIs de mapas (Google Maps, Waze) para obter pesos de aresta (tempo) em tempo real, baseados no trÃ¡fego.Clustering AvanÃ§ado: Substituir o K-Means por algoritmos mais robustos como o DBSCAN (que pode identificar Ã¡reas densas de pedidos) ou uma variante do K-Means que use o tempo de rota (via A*) como mÃ©trica de distÃ¢ncia, em vez da distÃ¢ncia Euclidiana.Modelo Preditivo: Usar dados histÃ³ricos de entrega para treinar um modelo de RegressÃ£o que preveja o tempo de entrega com mais precisÃ£o, considerando dia da semana, hora e clima.OtimizaÃ§Ã£o Multi-Objetivo: Incluir restriÃ§Ãµes reais, como a capacidade da mochila do entregador e o tempo mÃ¡ximo que um pedido pode esperar.
